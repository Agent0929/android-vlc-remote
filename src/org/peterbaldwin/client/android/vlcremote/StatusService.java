/*-
 *  Copyright (C) 2010 Peter Baldwin   
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package org.peterbaldwin.client.android.vlcremote;

import java.io.IOException;
import java.io.InputStream;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.StatusLine;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;

import android.app.Service;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Process;
import android.util.Log;
import android.util.Xml;

/**
 * Sends commands to a VLC server and receives &amp; broadcasts the status.
 */
public class StatusService extends Service implements Handler.Callback {

	private static final String TAG = "StatusService";

	/**
	 * Indicates if the command was generated by the user or programmatically.
	 * <p>
	 * This value is echoed back in the broadcast response.
	 * <p>
	 * The value can be used to determine whether or not it is appropriate to
	 * display an error message to the user.
	 */
	public static final String EXTRA_PROGRAMMATIC = "vlc:programmatic";

	/**
	 * Instructs the service to only run the command if the media is playing.
	 */
	public static final String EXTRA_ONLY_IF_PLAYING = "vlc:only-if-playing";

	/**
	 * Instructs the service to only run the command if the media is paused.
	 */
	public static final String EXTRA_ONLY_IF_PAUSED = "vlc:only-if-paused";

	/**
	 * Instructs the service to call {@link VLC#setResumeOnIdle()} if and only
	 * if the command is executed successfully.
	 */
	public static final String EXTRA_SET_RESUME_ON_IDLE = "vlc:set-resume-on-idle";

	private static final int HANDLE_STATUS = 1;
	private static final int HANDLE_ALBUM_ART = 2;
	private static final int HANDLE_STOP = 3;

	private static final int FLAG_PROGRAMMATIC = 1 << 0;
	private static final int FLAG_ONLY_IF_PLAYING = 1 << 1;
	private static final int FLAG_ONLY_IF_PAUSED = 1 << 2;
	private static final int FLAG_SET_RESUME_ON_IDLE = 1 << 3;

	private static boolean isCommand(Uri uri) {
		return !uri.getQueryParameters("command").isEmpty();
	}

	/**
	 * Erases any commands from the URI.
	 */
	private static Uri readOnly(Uri uri) {
		Uri.Builder builder = uri.buildUpon();
		builder.encodedQuery("");
		return builder.build();
	}

	private static boolean isSeek(Uri uri) {
		return "seek".equals(uri.getQueryParameter("command"));
	}

	private static boolean isVolume(Uri uri) {
		return "volume".equals(uri.getQueryParameter("command"));
	}

	private static boolean isAbsoluteValue(Uri uri) {
		String value = uri.getQueryParameter("val");
		return value != null && !value.startsWith("+")
				&& !value.startsWith("-");
	}

	private static HttpClient createHttpClient() {
		HttpParams params = new BasicHttpParams();
		HttpConnectionParams.setConnectionTimeout(params, 20 * 1000);
		HttpConnectionParams.setSoTimeout(params, 20 * 1000);
		HttpConnectionParams.setSocketBufferSize(params, 8192);
		SchemeRegistry schemeRegistry = new SchemeRegistry();
		schemeRegistry.register(new Scheme("http", PlainSocketFactory
				.getSocketFactory(), 80));
		schemeRegistry.register(new Scheme("https", SSLSocketFactory
				.getSocketFactory(), 443));
		ClientConnectionManager manager = new ThreadSafeClientConnManager(
				params, schemeRegistry);
		return new DefaultHttpClient(manager, params);
	}

	private HttpClient mHttpClient;

	private Handler mStatusHandler;

	private Handler mAlbumArtHandler;

	private Handler mCommandHandler;

	private AtomicInteger mSequenceNumber;

	@Override
	public void onCreate() {
		super.onCreate();

		mSequenceNumber = new AtomicInteger();

		mHttpClient = createHttpClient();

		mStatusHandler = startHandlerThread("StatusThread");

		// Create a separate thread for album art requests
		// because the request can be very slow.
		mAlbumArtHandler = startHandlerThread("AlbumArtThread");

		// Create a separate thread for commands to improve latency
		// (commands shouldn't have to wait for partially complete reads).
		mCommandHandler = startHandlerThread("CommandThread");
	}

	@Override
	public void onDestroy() {
		stopHandlerThread(mStatusHandler);
		stopHandlerThread(mCommandHandler);
		stopHandlerThread(mAlbumArtHandler);
		mHttpClient.getConnectionManager().shutdown();
		super.onDestroy();
	}

	private Handler startHandlerThread(String name) {
		HandlerThread thread = new HandlerThread(name,
				Process.THREAD_PRIORITY_BACKGROUND);
		thread.start();
		Looper looper = thread.getLooper();
		Handler.Callback callback = this;
		return new Handler(looper, callback);
	}

	private void stopHandlerThread(Handler handler) {
		Looper looper = handler.getLooper();
		looper.quit();
	}

	private <T> T getResponse(Uri uri, XmlResponseHandler<T> handler)
			throws IOException, SAXException {
		HttpGet request = new HttpGet(String.valueOf(uri));
		HttpResponse response = mHttpClient.execute(request);
		HttpEntity entity = response.getEntity();
		try {
			StatusLine statusLine = response.getStatusLine();
			int statusCode = statusLine.getStatusCode();
			if (statusCode == HttpStatus.SC_OK) {
				InputStream in = entity.getContent();
				try {
					String encodingName = EntityUtils.getContentCharSet(entity);
					Xml.Encoding encoding = Xml.findEncodingByName(encodingName);
					ContentHandler contentHandler = handler.getContentHandler();
					Xml.parse(in, encoding, contentHandler);
					return handler.getResponse();
				} finally {
					in.close();
				}
			} else {
				throw new IOException("Unexpected status code: " + statusCode);
			}
		} finally {
			if (entity != null) {
				entity.consumeContent();
			}
		}
	}

	private Status getStatus(Uri uri) throws IOException, SAXException {
		StatusResponseHandler handler = new StatusResponseHandler();
		return getResponse(uri, handler);
	}

	private Bitmap getBitmap(Uri uri) throws IOException {
		HttpGet request = new HttpGet(String.valueOf(uri));

		// In some versions of VLC, album art requests can take a long time
		// to return if there is no album art available for the current track.
		// Set a short timeout to prevent a backlog of requests in this queue.
		HttpParams params = new BasicHttpParams();
		HttpConnectionParams.setSoTimeout(params, 2000);
		request.setParams(params);

		HttpResponse response = mHttpClient.execute(request);
		HttpEntity httpEntity = response.getEntity();
		try {
			StatusLine statusLine = response.getStatusLine();
			int statusCode = statusLine.getStatusCode();
			if (statusCode == HttpStatus.SC_OK) {
				InputStream in = httpEntity.getContent();
				try {
					return BitmapFactory.decodeStream(in);
				} finally {
					in.close();
				}
			} else {
				throw new IOException("Unexpected status code: " + statusCode);
			}
		} finally {
			if (httpEntity != null) {
				httpEntity.consumeContent();
			}
		}
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		String action = (intent != null) ? intent.getAction() : null;
		Uri uri = (intent != null) ? intent.getData() : null;
		if (VLC.ACTION_STATUS.equals(action) && uri != null) {
			if (isCommand(uri)) {
				// A command will change the status,
				// so cancel any unsent requests to
				// query the status
				mStatusHandler.removeMessages(HANDLE_STATUS);
			}

			if (isSeek(uri) || isVolume(uri)) {
				if (isAbsoluteValue(uri)) {
					// Seeking to an absolute position or volume
					// invalidates any existing requests to change
					// the position or volume.
					mCommandHandler.removeMessages(HANDLE_STATUS);
				}
			}

			Handler handler = isCommand(uri) ? mCommandHandler : mStatusHandler;
			if (isCommand(uri) || !handler.hasMessages(HANDLE_STATUS)) {
				int sequenceNumber = isCommand(uri) ? mSequenceNumber
						.incrementAndGet() : mSequenceNumber.get();
				int flags = 0;
				if (intent.getBooleanExtra(EXTRA_PROGRAMMATIC, true)) {
					flags |= FLAG_PROGRAMMATIC;
				}
				if (intent.getBooleanExtra(EXTRA_ONLY_IF_PLAYING, false)) {
					flags |= FLAG_ONLY_IF_PLAYING;
				}
				if (intent.getBooleanExtra(EXTRA_ONLY_IF_PAUSED, false)) {
					flags |= FLAG_ONLY_IF_PAUSED;
				}
				if (intent.getBooleanExtra(EXTRA_SET_RESUME_ON_IDLE, false)) {
					flags |= FLAG_SET_RESUME_ON_IDLE;
				}
				Message msg = handler.obtainMessage(HANDLE_STATUS,
						sequenceNumber, flags, uri);
				handler.sendMessage(msg);
			}
		} else if (VLC.ACTION_ALBUM_ART.equals(action) && uri != null) {
			int sequenceNumber = mSequenceNumber.get();
			Message msg = mAlbumArtHandler.obtainMessage(HANDLE_ALBUM_ART,
					sequenceNumber, -1, uri);
			msg.sendToTarget();
		}
		{
			// Stop the service if no new Intents are received for 20 seconds
			Handler handler = mCommandHandler;
			Message msg = handler.obtainMessage(HANDLE_STOP, startId, -1);
			handler.sendMessageDelayed(msg, 20 * 1000);
		}
	}
	
	/** {@inheritDoc} */
	public boolean handleMessage(Message msg) {
		switch (msg.what) {
		case HANDLE_STATUS: {
			Uri uri = (Uri) msg.obj;
			int sequenceNumber = msg.arg1;
			int flags = msg.arg2;
			if (sequenceNumber == mSequenceNumber.get()) {
				boolean programmatic = ((flags & FLAG_PROGRAMMATIC) != 0);
				boolean setResumeOnIdle = ((flags & FLAG_SET_RESUME_ON_IDLE) != 0);
				boolean onlyIfPlaying = ((flags & FLAG_ONLY_IF_PLAYING) != 0);
				boolean onlyIfPaused = ((flags & FLAG_ONLY_IF_PAUSED) != 0);
				boolean conditional = onlyIfPlaying || onlyIfPaused;
				try {
					if (conditional) {
						Status status = getStatus(readOnly(uri));
						if (onlyIfPlaying && !status.isPlaying()) {
							return true;
						}
						if (onlyIfPaused && !status.isPaused()) {
							return true;
						}
					}
					Status status = getStatus(uri);
					if (sequenceNumber == mSequenceNumber.get()) {
						sendBroadcast(VLC.createStatusBroadcastIntent(status));
						if (isCommand(uri)) {
							// Check the status again after the command
							// has had time to take effect.
							msg = mStatusHandler.obtainMessage(HANDLE_STATUS,
									sequenceNumber, 0, readOnly(uri));
							mStatusHandler.sendMessageDelayed(msg, 500);
						}
					} else {
						Log.d(TAG, "Dropped stale status response: " + uri);
					}
					if (setResumeOnIdle) {
						VLC vlc = new VLC(this);
						vlc.setResumeOnIdle();
					}
				} catch (Throwable tr) {
					String message = String.valueOf(tr);
					Log.e(TAG, message, tr);
					Intent broadcast = VLC.createExceptionBroadcastIntent(tr);
					broadcast.putExtra(EXTRA_PROGRAMMATIC, programmatic);
					sendBroadcast(broadcast);
				}
			} else {
				Log.d(TAG, "Dropped stale status request: " + uri);
			}
			return true;
		}
		case HANDLE_ALBUM_ART: {
			Uri uri = (Uri) msg.obj;
			int sequenceNumber = msg.arg1;
			if (sequenceNumber == mSequenceNumber.get()) {
				try {
					Bitmap bitmap = getBitmap(uri);
					if (sequenceNumber == mSequenceNumber.get()) {
						sendBroadcast(VLC.createAlbumArtBroadcastIntent(bitmap));
					} else {
						Log.d(TAG, "Dropped stale album art response: " + uri);
					}
				} catch (Throwable tr) {
					String message = String.valueOf(tr);
					Log.e(TAG, message, tr);
					sendBroadcast(VLC.createExceptionBroadcastIntent(tr));
				}
			} else {
				Log.d(TAG, "Dropped stale album art request: " + uri);
			}
			return true;
		}
		case HANDLE_STOP: {
			int startId = msg.arg1;
			stopSelf(startId);
			return true;
		}
		default:
			return false;
		}
	}

	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}
}
